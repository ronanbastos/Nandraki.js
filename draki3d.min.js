class ThreeCore{constructor(){if(ThreeCore.instance)return ThreeCore.instance;this.scene=new THREE.Scene,this.camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,.1,1e3),this.renderer=new THREE.WebGLRenderer({alpha:!0}),this.renderer.setSize(window.innerWidth,window.innerHeight),ThreeCore.instance=this}init(t){t.appendChild(this.renderer.domElement),this.animate()}animate(){requestAnimationFrame((()=>this.animate())),this.scene.traverse((t=>{t.userData.scripts&&t.userData.scripts.forEach((e=>e(t)));const e=t.userData.components||{};for(let s in e){const n=e[s];"function"==typeof n.update&&n.update(t)}})),this.renderer.render(this.scene,this.camera)}}class ThreeFactory{createLight(){return new THREE.PointLight(16777215,1)}createCube(){const t=new THREE.BoxGeometry,e=new THREE.MeshStandardMaterial({color:65280});return new THREE.Mesh(t,e)}createCamera(){return new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,.1,1e3)}}class EntityBuilder{constructor(){this.entity=new THREE.Object3D}addMesh(t){return this.entity.add(t),this}setPosition(t,e,s){return this.entity.position.set(t,e,s),this}build(){return this.entity}}class PrototypeFactory{constructor(){this.prototypes={}}register(t,e){this.prototypes[t]=e}clone(t){return this.prototypes[t]?.clone()??null}}class ComponentRegistry{static components={};static register(t,e){this.components[t]=e}static instantiate(t,...e){const s=this.components[t];return s?new s(...e):null}}const TagSystem={add(t,e){t.userData.tags||(t.userData.tags=new Set),t.userData.tags.add(e)},has:(t,e)=>t.userData.tags?.has(e)??!1,remove(t,e){t.userData.tags?.delete(e)},getAll(t){const e=new ThreeCore,s=[];return e.scene.traverse((e=>{e.userData.tags?.has(t)&&s.push(e)})),s}};class Game{static create(t,e=null){const s=new ThreeFactory,n={cube:"createCube",camera:"createCamera",light:"createLight"}[t];if(!n||"function"!=typeof s[n])throw new Error(`Tipo de objeto desconhecido: "${t}"`);const a=s[n]();return e&&(a.name=e),a}}const drak=function(){const t=new ThreeCore,e={};return function s(n=null){if(!n)return{cache:{set(t,s){e[t]=s},get:t=>e[t]},byTag(e){const n=[];return t.scene.traverse((t=>{t.userData.tags?.has(e)&&n.push(s(t.name))})),n}};const a=t.scene.getObjectByName(n);return a?{set(t,e){const s=t.split(".");let n=a;for(;s.length>1;)n=n[s.shift()];n[s[0]]=e},get(t){const e=t.split(".");let s=a;for(let t of e)s=s[t];return s},script(t){a.userData.scripts||(a.userData.scripts=[]),a.userData.scripts.push(t)},component:t=>a.userData?.components?.[t]??null,addComponent(t,e){a.userData.components||(a.userData.components={}),a.userData.components[t]=e},removeComponent(t){a.userData.components&&delete a.userData.components[t]},addTag(t){a.userData.tags||(a.userData.tags=new Set),a.userData.tags.add(t)},removeTag(t){a.userData.tags?.delete(t)},hasTag:t=>a.userData.tags?.has(t)??!1,echo(){console.log(a)},eye(){a.material?.color&&(a.userData.originalColor||(a.userData.originalColor=a.material.color.clone()),a.material.color.set(16776960),setTimeout((()=>{a.material&&a.userData.originalColor&&a.material.color.copy(a.userData.originalColor)}),1e3))},callTo(e){const s=t.scene.getObjectByName(e);s&&console.log("Chamado:",s)},touch(e){const s=t.scene.getObjectByName(e);s?.userData.scripts&&s.userData.scripts.forEach((t=>t(s)))},ref:t=>a.userData?.[t]??null,link(e){const s=t.scene.getObjectByName(e);s&&s.add(a)},pointTo(e){const s=t.scene.getObjectByName(e);s?.position&&a.lookAt(s.position)},hook(t){if("function"==typeof t)try{return t(a)}catch(t){console.error(`hook: erro ao executar função para "${a.name}"`,t)}else console.warn("hook: argumento não é uma função válida")}}:(console.warn(`Objeto "${n}" não encontrado`),null)}}();class HUD{constructor(){this.canvas=document.createElement("canvas"),this.ctx=this.canvas.getContext("2d"),this.canvas.style.position="absolute",this.canvas.style.top="0",this.canvas.style.left="0",this.canvas.style.pointerEvents="none",this.canvas.style.zIndex="1000",this.canvas.style.background="transparent",document.body.appendChild(this.canvas),this.items=new Map,this.images=[],this.buttons=new Map,this.downMap=new Map,this.upMap=new Map,this.activeTouches=new Set,this.resize(),window.addEventListener("resize",(()=>this.resize())),this.canvas.addEventListener("pointerdown",(t=>this.handleDown(t))),this.canvas.addEventListener("pointerup",(t=>this.handleUp(t)))}resize(){this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight}add(t,e,s=10,n=10,a="#ffffff",o="16px monospace"){this.items.set(t,{value:e,x:s,y:n,color:a,font:o})}update(t,e){this.items.has(t)&&(this.items.get(t).value=e)}img(t,e,s,n,a){const o=new Image;o.onload=()=>{this.images.push({image:o,x:e,y:s,width:n,height:a}),this.draw()},o.src=t}touch(t,e,s,n,a,o={}){return this.buttons.set(t,{name:t,x:e,y:s,width:n,height:a,color:o.color||"#ffffff22",border:o.border||"#ffffff55"}),this.canvas.style.pointerEvents="auto",this}onDown(t,e){return"function"==typeof e&&this.downMap.set(t,e),this}onUp(t,e){return"function"==typeof e&&this.upMap.set(t,e),this}handleDown(t){const e=t.clientX,s=t.clientY;for(const t of this.buttons.values())if(e>=t.x&&e<=t.x+t.width&&s>=t.y&&s<=t.y+t.height){this.activeTouches.add(t.name);const e=this.downMap.get(t.name);e&&e();break}}handleUp(t){const e=t.clientX,s=t.clientY;for(const t of this.buttons.values())if(e>=t.x&&e<=t.x+t.width&&s>=t.y&&s<=t.y+t.height&&this.activeTouches.has(t.name)){const e=this.upMap.get(t.name);e&&e();break}this.activeTouches.clear()}style(t={}){Object.assign(this.canvas.style,t)}ctxStyle(t){const e=this.items.get(t);return e?(this.ctx.fillStyle=e.color,this.ctx.font=e.font,this.ctx):this.ctx}draw(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);for(const{image:t,x:e,y:s,width:n,height:a}of this.images)this.ctx.drawImage(t,e,s,n,a);for(const[t,{value:e,x:s,y:n,color:a,font:o}]of this.items)this.ctx.fillStyle=a,this.ctx.font=o,this.ctx.fillText(`${t}: ${e}`,s,n);for(const t of this.buttons.values())this.ctx.fillStyle=t.color,this.ctx.fillRect(t.x,t.y,t.width,t.height),this.ctx.strokeStyle=t.border,this.ctx.strokeRect(t.x,t.y,t.width,t.height)}}class Animax{constructor(){if(Animax.instance)return Animax.instance;this.mixers=new Map,this.actions=new Map,this.currentActions=new Map,this.clock=new THREE.Clock,Animax.instance=this}add(t,e){const s=t.name;if(!s)return void console.error("Animax: O modelo precisa de um nome para ser adicionado.");const n=new THREE.AnimationMixer(t);this.mixers.set(s,n);const a=new Map;e.forEach((t=>{a.set(t.name,n.clipAction(t))})),this.actions.set(s,a)}play(t,e,s=.3){const n=this.actions.get(t);if(!n)return;const a=n.get(e);if(!a)return void console.warn(`Animax: Animação "${e}" não encontrada para o modelo "${t}".`);const o=this.currentActions.get(t);o!==a&&(o&&o.fadeOut(s),a.reset().setLoop(THREE.LoopRepeat).fadeIn(s).play(),this.currentActions.set(t,a))}playOnce(t,e,s){const n=this.actions.get(t),a=this.mixers.get(t);if(!n||!a)return;const o=n.get(e);if(!o)return void console.warn(`Animax: Animação "${e}" não encontrada para o modelo "${t}".`);const i=this.currentActions.get(t);i&&i.fadeOut(.3),o.reset().setLoop(THREE.LoopOnce).fadeIn(.3).play(),o.clampWhenFinished=!0,this.currentActions.set(t,o);const r=e=>{e.action===o&&(a.removeEventListener("finished",r),this.currentActions.set(t,null),s&&s())};a.addEventListener("finished",r)}stop(t,e=.3){const s=this.currentActions.get(t);s&&(s.fadeOut(e),this.currentActions.set(t,null))}start(){this._update()}_update(){requestAnimationFrame((()=>this._update()));const t=this.clock.getDelta();for(const e of this.mixers.values())e.update(t)}}const animax=new Animax;
