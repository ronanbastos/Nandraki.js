class ThreeCore{constructor(){if(ThreeCore.instance)return ThreeCore.instance;this.scene=new THREE.Scene,this.camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,.1,1e3),this.renderer=new THREE.WebGLRenderer({alpha:!0}),this.renderer.setSize(window.innerWidth,window.innerHeight),ThreeCore.instance=this}init(t){t.appendChild(this.renderer.domElement),this.animate()}animate(){requestAnimationFrame((()=>this.animate())),this.scene.traverse((t=>{t.userData.scripts&&t.userData.scripts.forEach((e=>e(t)));const e=t.userData.components||{};for(let s in e){const n=e[s];"function"==typeof n.update&&n.update(t)}})),this.renderer.render(this.scene,this.camera)}}class ThreeFactory{createLight(){return new THREE.PointLight(16777215,1)}createCube(){const t=new THREE.BoxGeometry,e=new THREE.MeshStandardMaterial({color:65280});return new THREE.Mesh(t,e)}createCamera(){return new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,.1,1e3)}}class EntityBuilder{constructor(){this.entity=new THREE.Object3D}addMesh(t){return this.entity.add(t),this}setPosition(t,e,s){return this.entity.position.set(t,e,s),this}build(){return this.entity}}class PrototypeFactory{constructor(){this.prototypes={}}register(t,e){this.prototypes[t]=e}clone(t){return this.prototypes[t]?.clone()??null}}class ComponentRegistry{static components={};static register(t,e){this.components[t]=e}static instantiate(t,...e){const s=this.components[t];return s?new s(...e):null}}const TagSystem={add(t,e){t.userData.tags||(t.userData.tags=new Set),t.userData.tags.add(e)},has:(t,e)=>t.userData.tags?.has(e)??!1,remove(t,e){t.userData.tags?.delete(e)},getAll(t){const e=new ThreeCore,s=[];return e.scene.traverse((e=>{e.userData.tags?.has(t)&&s.push(e)})),s}};class Game{static create(t,e=null){const s=new ThreeFactory,n={cube:"createCube",camera:"createCamera",light:"createLight"}[t];if(!n||"function"!=typeof s[n])throw new Error(`Tipo de objeto desconhecido: "${t}"`);const i=s[n]();return e&&(i.name=e),i}}const drak=function(){const t=new ThreeCore,e={};return function s(n=null){if(!n)return{cache:{set(t,s){e[t]=s},get:t=>e[t]},byTag(e){const n=[];return t.scene.traverse((t=>{t.userData.tags?.has(e)&&n.push(s(t.name))})),n}};const i=t.scene.getObjectByName(n);return i?{set(t,e){const s=t.split(".");let n=i;for(;s.length>1;)n=n[s.shift()];n[s[0]]=e},get(t){const e=t.split(".");let s=i;for(let t of e)s=s[t];return s},script(t){i.userData.scripts||(i.userData.scripts=[]),i.userData.scripts.push(t)},component:t=>i.userData?.components?.[t]??null,addComponent(t,e){i.userData.components||(i.userData.components={}),i.userData.components[t]=e},removeComponent(t){i.userData.components&&delete i.userData.components[t]},addTag(t){i.userData.tags||(i.userData.tags=new Set),i.userData.tags.add(t)},removeTag(t){i.userData.tags?.delete(t)},hasTag:t=>i.userData.tags?.has(t)??!1,echo(){console.log(i)},eye(){i.material?.color&&(i.userData.originalColor||(i.userData.originalColor=i.material.color.clone()),i.material.color.set(16776960),setTimeout((()=>{i.material&&i.userData.originalColor&&i.material.color.copy(i.userData.originalColor)}),1e3))},callTo(e){const s=t.scene.getObjectByName(e);s&&console.log("Chamado:",s)},touch(e){const s=t.scene.getObjectByName(e);s?.userData.scripts&&s.userData.scripts.forEach((t=>t(s)))},ref:t=>i.userData?.[t]??null,link(e){const s=t.scene.getObjectByName(e);s&&s.add(i)},pointTo(e){const s=t.scene.getObjectByName(e);s?.position&&i.lookAt(s.position)},hook(t){if("function"==typeof t)try{return t(i)}catch(t){console.error(`hook: erro ao executar função para "${i.name}"`,t)}else console.warn("hook: argumento não é uma função válida")}}:(console.warn(`Objeto "${n}" não encontrado`),null)}}();class HUD{constructor(){this.canvas=document.createElement("canvas"),this.ctx=this.canvas.getContext("2d"),this.canvas.style.position="absolute",this.canvas.style.top="0",this.canvas.style.left="0",this.canvas.style.pointerEvents="none",this.canvas.style.zIndex="1000",this.canvas.style.background="transparent",document.body.appendChild(this.canvas),this.items=new Map,this.images=[],this.buttons=new Map,this.downMap=new Map,this.upMap=new Map,this.activeTouches=new Set,this.resize(),window.addEventListener("resize",(()=>this.resize())),this.canvas.addEventListener("pointerdown",(t=>this.handleDown(t))),this.canvas.addEventListener("pointerup",(t=>this.handleUp(t)))}resize(){this.canvas.width=window.innerWidth,this.canvas.height=window.innerHeight}add(t,e,s=10,n=10,i="#ffffff",a="16px monospace"){this.items.set(t,{value:e,x:s,y:n,color:i,font:a})}update(t,e){this.items.has(t)&&(this.items.get(t).value=e)}img(t,e,s,n,i){const a=new Image;a.onload=()=>{this.images.push({image:a,x:e,y:s,width:n,height:i}),this.draw()},a.src=t}touch(t,e,s,n,i,a={}){return this.buttons.set(t,{name:t,x:e,y:s,width:n,height:i,color:a.color||"#ffffff22",border:a.border||"#ffffff55"}),this.canvas.style.pointerEvents="auto",this}onDown(t,e){return"function"==typeof e&&this.downMap.set(t,e),this}onUp(t,e){return"function"==typeof e&&this.upMap.set(t,e),this}handleDown(t){const e=t.clientX,s=t.clientY;for(const t of this.buttons.values())if(e>=t.x&&e<=t.x+t.width&&s>=t.y&&s<=t.y+t.height){this.activeTouches.add(t.name);const e=this.downMap.get(t.name);e&&e();break}}handleUp(t){const e=t.clientX,s=t.clientY;for(const t of this.buttons.values())if(e>=t.x&&e<=t.x+t.width&&s>=t.y&&s<=t.y+t.height&&this.activeTouches.has(t.name)){const e=this.upMap.get(t.name);e&&e();break}this.activeTouches.clear()}style(t={}){Object.assign(this.canvas.style,t)}ctxStyle(t){const e=this.items.get(t);return e?(this.ctx.fillStyle=e.color,this.ctx.font=e.font,this.ctx):this.ctx}draw(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);for(const{image:t,x:e,y:s,width:n,height:i}of this.images)this.ctx.drawImage(t,e,s,n,i);for(const[t,{value:e,x:s,y:n,color:i,font:a}]of this.items)this.ctx.fillStyle=i,this.ctx.font=a,this.ctx.fillText(`${t}: ${e}`,s,n);for(const t of this.buttons.values())this.ctx.fillStyle=t.color,this.ctx.fillRect(t.x,t.y,t.width,t.height),this.ctx.strokeStyle=t.border,this.ctx.strokeRect(t.x,t.y,t.width,t.height)}}class Animax{constructor(){if(Animax.instance)return Animax.instance;this.mixers=new Map,this.actions=new Map,this.currentActions=new Map,this.clock=new THREE.Clock,Animax.instance=this}add(t,e){const s=t.name;if(!s)return void console.error("Animax: O modelo precisa de um nome para ser adicionado.");const n=new THREE.AnimationMixer(t);this.mixers.set(s,n);const i=new Map;e.forEach((t=>{i.set(t.name,n.clipAction(t))})),this.actions.set(s,i)}play(t,e,s=.3){const n=this.actions.get(t);if(!n)return;const i=n.get(e);if(!i)return void console.warn(`Animax: Animação "${e}" não encontrada para o modelo "${t}".`);const a=this.currentActions.get(t);a!==i&&(a&&a.fadeOut(s),i.reset().setLoop(THREE.LoopRepeat).fadeIn(s).play(),this.currentActions.set(t,i))}playOnce(t,e,s){const n=this.actions.get(t),i=this.mixers.get(t);if(!n||!i)return;const a=n.get(e);if(!a)return void console.warn(`Animax: Animação "${e}" não encontrada para o modelo "${t}".`);const o=this.currentActions.get(t);o&&o.fadeOut(.3),a.reset().setLoop(THREE.LoopOnce).fadeIn(.3).play(),a.clampWhenFinished=!0,this.currentActions.set(t,a);const r=e=>{e.action===a&&(i.removeEventListener("finished",r),this.currentActions.set(t,null),s&&s())};i.addEventListener("finished",r)}stop(t,e=.3){const s=this.currentActions.get(t);s&&(s.fadeOut(e),this.currentActions.set(t,null))}start(){this._update()}_update(){requestAnimationFrame((()=>this._update()));const t=this.clock.getDelta();for(const e of this.mixers.values())e.update(t)}}const animax=new Animax;class Physix{constructor(){if(Physix.instance)return Physix.instance;this.playerBox=new THREE.Box3,this.wallBox=new THREE.Box3,Physix.instance=this}check(t,e,s,n){const i=ThreeCore.instance;if(!i)return!1;const a=i.scene.getObjectByName(t);if(!a)return!1;this.playerBox.setFromObject(a),this.playerBox.min.x+=e,this.playerBox.max.x+=e,this.playerBox.min.z+=s,this.playerBox.max.z+=s;const o=[];i.scene.traverse((t=>{t.isObject3D&&t.userData.tags&&t.userData.tags.has(n)&&o.push(t)}));for(let t of o)if(this.wallBox.setFromObject(t),this.playerBox.intersectsBox(this.wallBox))return!0;return!1}}const physix=new Physix;class Gravix{constructor(){if(Gravix.instance)return Gravix.instance;this.gravity=.015,this.floorY=0,this.velocityY=0,this.isGrounded=!1,Gravix.instance=this}update(t,e,s=.35){const n=ThreeCore.instance.scene.getObjectByName(t);n&&(this.velocityY-=this.gravity,e&&this.isGrounded&&(this.velocityY=s,this.isGrounded=!1),n.position.y+=this.velocityY,n.position.y<=this.floorY?(n.position.y=this.floorY,this.velocityY=0,this.isGrounded=!0):this.isGrounded=!1)}}const gravix=new Gravix;
