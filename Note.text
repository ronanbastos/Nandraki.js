  _________________________________________
  [ative anim inimigo]
  
  if (inimigo.mirror == 0) {
                game.force_obj("inimigo", inimigo.di, inimigo.up, false);
                
            } else {

                game.force_obj("inimigo", inimigo.di, inimigo.up, true);
            
            }
        if(inimigo.anim == "parado"){

            game.img_frame("inimigo","img[1]inimigo",64, 64, 8,0,8, 8); 
            
        }  
            if (inimigo.anim == "correr") {
                if (inimigo.frame >=2 ) inimigo.frame = 0;
                game.img_frame("inimigo","img[1]inimigo",64, 64, 2, inimigo.frame++, 2, 0);


            }
            if (inimigo.anim == "atk") {
                if (inimigo.frame >=3 ) inimigo.frame = 0;
                game.img_frame("inimigo","img[2]inimigo",64, 64, 3, inimigo.frame++, 3, 0);


            }
 
 
 _Move: function () {
          if(find==false && normalizar==true){       
            player.di=inimigo.di +Math.floor(Math.random() * 250)         
            console.log("limite: "+limite+"/ mirror: "+inimigo.mirror)
          }else if(find==true){
            limite=Math.floor(Math.random() * 100)+player.di;
          }
          if(player.di==inimigo.di+10 && inimigo.mirror !=player.mirror  ){
            find=true;
        }
         if(game.check_id("player")==false && find==false &&  normalizar==true){
            anim="parado"
        } else if(game.check_id("inimigo")==true){
           
            if(game.check_colidir("box_player","box_inimigo")==true ){
                Inimigo.AnimationFrame();
                inimigo.anim="atk"
                player.vida-=1
                find=true;
                if(player.vida<=0){
                    normalizar=true;
                    find=false;
                }
            }else{
                if( find==true &&  normalizar==false){
                    Inimigo.AnimationFrame()
                     inimigo.anim="correr"
                }else{
                    anim="parado"
                }
                
                if(player.up>inimigo.up && player.di<inimigo.di && inimigo.mirror==1 && find==true &&  normalizar==false ){
                    inimigo.up+=2 

                }else if(player.up<inimigo.up && player.di<inimigo.di && inimigo.mirror==1  && find==true &&  normalizar==false ){
                    inimigo.up-=2 

                }else if(player.up>inimigo.up && player.di>inimigo.di && inimigo.mirror==0 && find==true &&  normalizar==false){
                    inimigo.up+=2 

                }else if(player.up<inimigo.up && player.di>inimigo.di && inimigo.mirror==0 && find==true &&  normalizar==false ){
                    inimigo.up-=2 

                }

                 if(inimigo.di>=-30 && inimigo.mirror==0 && find==true &&  normalizar==false){
                    inimigo.di+=2
                    }
                    if( inimigo.di >= limite && find==true &&  normalizar==false){
                    
                    inimigo.mirror=1;
                    
                    }
                    if(inimigo.di>=-30 && inimigo.mirror==1 && find==true &&  normalizar==false){
                        inimigo.di-=2
                  
                    }      
                   if(inimigo.di==-30 || player.di==inimigo.di+20 && find==true &&  normalizar==false ){
                            inimigo.mirror=0
                    }
            
                    }
                }    
        },
_________________________________________
// seleciona elemento
let el = document.getElementById('box');
// utiliza m√©todo
let elCoordenadas = el.getBoundingClientRect();
// verificar as propriedades com as coord
console.log(elCoordenadas);
_________________________________________
var div = document.createElement("div");
div.style.width = "100px";
div.style.height = "100px";
div.style.background = "red";
div.style.color = "white";
div.innerHTML = "Hello";

document.getElementById("main").appendChild(div); ou document.body.appendChild(div);

<body>
<div id="main"></div>
</body>

var div = document.getElementById("player");
div.style.width = "100px";
div.style.height = "100px";
div.style.background = "red";
div.style.color = "white";
div.innerHTML = "Hello";

document.getElementById("main").appendChild(div); ou document.body.appendChild(div);

_______________________________________________________________________________________
var DivA = document.querySelector("#DivA")
var DivB = document.querySelector("#DivB")
var Top = 0;//Se o T n√£o for maiusculo n√£o funciona no iframe do codepen
var left = 0;

//Fun√ß√£o de utilidade
var rangeIntersect = function(min0, max0, min1, max1) {
    return Math.max(min0, max0) >= Math.min(min1, max1) && Math.min(min0, max0) <= Math.max(min1, max1)
}

//Fun√ß√£o para detectar se 2 BoundingClientRect's est√£o colidindo
var rectIntersect = function (r0, r1) {
    return rangeIntersect(r0.left, r0.right, r1.left, r1.right) && rangeIntersect(r0.top, r0.bottom, r1.top, r1.bottom)
}

_____________________________________________

document.querySelector('body').addEventListener('keydown', function(event) {
 
	var tecla = event.keyCode;
	
	if(tecla == 13) {
	 
	 // tecla ENTER
		
	} else if(tecla == 27) {
	 
	 // tecla ESC
		
	} else if(tecla == 37) {
	 
	 // seta pra ESQUERDA
		
	} else if(tecla == 38) {
	 
	 // seta pra CIMA
		
	} else if(tecla == 39) {
	 
	 // seta pra DIREITA
		
	} else if(tecla == 40) {
	 
	 // seta pra BAIXO
		
	}
 
});
_____________________________________________________

// seleciona elemento
let el = document.getElementById('player');

// utiliza m√©todo
let elCoordenadas = el.getBoundingClientRect();

// verificar as propriedades com as coord
console.log(elCoordenadas

______________________________________________________

<img id="image" src="smiley.gif">

<script>
document.getElementById("image").src = "pic_mountain.jpg";
</script>
_______________________________________________________
<input type="text" id="myText" value="Hello">

<script>
document.getElementById("myText").value = "Have a nice day!";
</script>
_______________________________________________________
TOUCH CLICK
<span ontouchstart="countTouches(event)" ontouchend="countTouches(event)" id="demo">TOCOU AQUI = 0</span>.</p>


<script>
function countTouches(event) {
  var x = event.targetTouches.length;
  document.getElementById("demo").innerHTML = "TOCOU AQUI = "+x;
}
</script>
_______________________________________________________
TOUCH MOVE
<p ontouchmove="myFunction()">Touch this paragraph, and move the finger to trigger a function that will write "Hello World".</p>

<p><strong>Note:</strong> This example is for touch devices only.</p>

<p id="demo">RF</p>

<script>
function myFunction() {
  document.getElementById("demo").innerHTML = "Hello World";
}
</script>
__________________________________________________________
<script>
function myFunction(event) {
var x = document.createEvent("MouseEvent");
x.initMouseEvent("mouseover", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);

document.getElementById("myDiv").dispatchEvent(x);
}
</script>

<h1>The createEvent() Method</h1>

<p>The createEvent() method allows you to simulate any event.</p>

<p>In this example, the red div will get a new star every time you mouse over it:</p>

<div onmouseover="this.innerHTML += '*';" id="myDiv">*</div>

<br>
<button onclick="myFunction(event)">Simulate Mouse Over</button>

__________________________________________________________
CRIAR UI
var h = document.createElement("H1")                // Create a <h1> element
var t = document.createTextNode("Hello World");     // Create a text node
h.appendChild(t);                                   // Append the text to <h1>


__________________________________________________________


function SomenteNumero(v)
{      
  return v.replace(/\D/g,"");  
}

/*
A fun√ß√£o vai pegar o valor do rotateZ, mas somente o n√∫mero.
Exemplo:
    DE: <div id="ID" style="-webkit-transform: rotateZ(320deg);" ></div>
    PARA: 320

Entendeu?! :D
*/
var get_rotate = function()
{
    var z = SomenteNumero( document.getElementById(" ID ").style.WebkitTransform );
    return z;
}

/*
A m√°gica √© nesta fun√ß√£o milagrosa! rsrs'

window.body_largura = Largura do body em px.
window.body_altura =  Altura do body em px.
*/
var efeito_ir = function( velocidade )
{   
    var deg = get_rotate(); //Pega o valor do rotateZ atual
    var plus = velocidade; //$velocidade: quanto maior √© o valor, maior √© a dist√¢ncia. Recomendado √© de 10 √° 100

    var rotation = deg - 270;
    var dist = Math.sqrt( (window.body_largura * plus)^2 + (window.body_altura * plus)^2);
    var degtorad = Math.PI/180;

    var x = Math.cos(degtorad * (rotation)) * dist;
    var y = Math.sin(degtorad * (rotation)) * dist;

    x = Math.round( document.getElementById(" ID ").offsetLeft + (-x) );
    y = Math.round( document.getElementById(" ID ").offsetTop + (-y) );

    console.log("X: " + (x) );
    console.log("Y: " + (y) );

    document.getElementById(" ID ").style.top = y + "px";
    document.getElementById(" ID ").style.left = x + "px";  

}

camera 2d 

var myElement = document.getElementById('element_within_div');
var topPos = myElement.offsetTop;
The variable topPos is now set to the distance between the top of the scrolling div and the element you wish to have visible (in pixels).

Now we tell the div to scroll to that position using scrollTop:

document.getElementById('scrolling_div').scrollTop = topPos;



document.addEventListener('click', evt => {
  if (evt.path.indexOf(document.querySelector('div.search-results')) < 0) {
    alert('fora no div!');
  } else {
    alert('dentro do div!');
  }
}, true);

window.addEventListener("gamepadconnected", function(e) {
  console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
  e.gamepad.index, e.gamepad.id,
  e.gamepad.buttons.length, e.gamepad.axes.length);
});



window.addEventListener("gamepadconnected", function(e) {
  console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
  e.gamepad.index, e.gamepad.id,
  e.gamepad.buttons.length, e.gamepad.axes.length);
});


function gameLoop() {
  if(navigator.webkitGetGamepads) {
    var gp = navigator.webkitGetGamepads()[0];

    if(gp.buttons[0] == 1) {
      b--;
    } else if(gp.buttons[1] == 1) {
      a++;
    } else if(gp.buttons[2] == 1) {
      b++;
    } else if(gp.buttons[3] == 1) {
      a--;
    }
  } else {
    var gp = navigator.getGamepads()[0];

    if(gp.buttons[0].value > 0 || gp.buttons[0].pressed == true) {
      b--;
    } else if(gp.buttons[1].value > 0 || gp.buttons[1].pressed == true) {
      a++;
    } else if(gp.buttons[2].value > 0 || gp.buttons[2].pressed == true) {
      b++;
    } else if(gp.buttons[3].value > 0 || gp.buttons[3].pressed == true) {
      a--;
    }
  }

  ball.style.left = a*2 + "px";
  ball.style.top = b*2 + "px";

  var start = rAF(gameLoop);
};



 


class Ponto {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    static distancia(a, b) {
        const dx = a.x - b.x;
        const dy = a.y - b.y;

        return Math.hypot(dx, dy);
    }
}
//const p1 = new Ponto(1, 1);
//const p2 = new Ponto(2,2);
//p1.distancia; //undefined
//p2.distancia; //undefined
//console.log(Ponto.distancia(p1, p2));	


#map {
  height: 150vh;
  width: 70vw;
  background: linear-gradient(blue, green);
  touch-action: none;
}

___________________________________________________________________

<textarea id="code"></textarea>
<iframe id="output"></iframe>



var old = '';
 function update(){
  var textarea = document.getElementById('code');
  var iFrame = document.getElementById('output');
  var IframeDocument=document.getElementById('output').contentDocument
  if (old != textarea.value){
    old = textarea.value;
    iFrame.src="about:blank";
    IframeDocument.write(old);
  }

  window.setTimeout(update, 150);
 }
 window.onload=update();
___________________________________________________________________
mover objeto
<script>
var id = null;
function myMove() {
  var elem = document.getElementById("myAnimation");   
  var pos = 0;
  clearInterval(id);
  id = setInterval(frame, 10);
  function frame() {
    if (pos == 350) {
      clearInterval(id);
    } else {
      pos++; 
      elem.style.top = pos + 'px'; 
      elem.style.left = pos + 'px'; 
    }
  }
}
</script>
___________________________________________________________________

function reset1(){

    clearTimeout(my_time);
    document.getElementById('ball1').style.left= "500px";
    document.getElementById('ball1').style.top= "100px";
    document.getElementById('ball1').style.right= "100px";
    document.getElementById("msg").innerHTML="";

}



function move_img(str) {

    var x=document.getElementById('ball1').offsetTop;
    x= x +100;
    document.getElementById('ball1').style.top= x + "px";

}

function disp(){

    var step=1; // Change this step value

    var y=document.getElementById('ball1').offsetTop;
    var x=document.getElementById('ball1').offsetLeft;

        if(y < 100){
	        y= y +step; // DEFINA AQUI OS VALORES
                document.getElementById('ball1').style.top= y + "px"; // vertical movimento
            }else{
                if(x < 200){
                x= x +step; // DEFINA AQUI OS VALORES
                document.getElementById('ball1').style.left= x + "px"; // horizontal movimento
            }
    }
//////////////////////

}

function timer(){
disp();
var y=document.getElementById('ball1').offsetTop;
var x=document.getElementById('ball1').offsetLeft;
document.getElementById("msg").innerHTML="X: " + x + " Y : " + y
my_time=setTimeout('timer()',10);
}

___________________________________________________________________
Pode utilizar o m√©todo children para obter todos os elementos filhos do elemento pai e o appendChild para adicionar os elementos no novo elemento pai.

function mover() {
    origem = document.getElementById("origem");
    destino = document.getElementById("destino");

    filhos = Array.prototype.slice.call(origem.children); //Convertendo HTMLCollection para Array
    filhos.forEach(function(element, index) {
        destino.appendChild(element);
    });
}
___________________________________________________________________
function allowDrop(ev) {
  ev.preventDefault();
}

function drag(ev) {
  ev.dataTransfer.setData("text", ev.target.id);
}

function drop(ev) {
  ev.preventDefault();
  var data = ev.dataTransfer.getData("text");
  ev.target.appendChild(document.getElementById(data));
}

<div id="div1" ondrop="drop(event)" ondragover="allowDrop(event)"></div>

<img id="drag1" src="img_logo.gif" draggable="true" ondragstart="drag(event)" width="336" height="69">
___________________________________________________________________

<script>
function move(elem, duracao) {
  // altura do botao
  var btnH	= document.getElementById('btnMover').offsetHeight;
  // valor da posi√ß√£o a esquerda do elemento
  var left 	= elem.clientLeft;
  // valor da posi√ß√£o topo do elemento
  var top       = btnH - elem.clientTop;
  // fun√ß√£o a ser chamada at√© chegar a posi√ß√£o informada
  function deslocamento() {
    // incrementando contador
    left++;
   
    // aplicando estilo no elemento
    elem.style.left = left + 'px';
    elem.style.top  = top + 'px';
    // verificando se chegou ao ponto desejado
    if (left == 200 || top == 200)
      // interrompe o processo de deslocamento 
      clearInterval(id);
    }
   // desloca o elemento at√© 10 segundos
   // aumentando o valor, vai demorar mais para chegar
   var id = setInterval(deslocamento, duracao);
}

function move1(elem, duracao) {
  // altura do botao
  var btnH	= document.getElementById('btnMover').offsetHeight;
  // valor da posi√ß√£o a esquerda do elemento
  var left 	= elem.clientLeft;
  // valor da posi√ß√£o topo do elemento
  var top       = btnH - elem.clientTop;
  // fun√ß√£o a ser chamada at√© chegar a posi√ß√£o informada
  function deslocamento() {
    // incrementando contador
    left--;
    
    // aplicando estilo no elemento
    elem.style.left = left + 'px';

    // verificando se chegou ao ponto desejado
    if (left == 0 )
      // interrompe o processo de deslocamento 
      clearInterval(id1);
    }
   // desloca o elemento at√© 10 segundos
   // aumentando o valor, vai demorar mais para chegar
   var id1 = setInterval(deslocamento, duracao);
}
</script>
</head>
<body>
<input type="button" id="btnMover" value="Mover" onclick="move(elemento, 10)">
<input type="button" id="btnMover" value="Mover" onclick="move1(elemento, 10)">
<div id="elemento">clique para mover</div>
__________________________________________________________________________________
canvas

<body onload="startGame()">
<script>

var myGamePiece;

function startGame() {
    myGamePiece = new component(30, 30, "red", 80, 75);
    myGameArea.start();
}

var myGameArea = {
    canvas : document.createElement("canvas"),
    start : function() {
        this.canvas.width = 480;
        this.canvas.height = 270;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        this.interval = setInterval(updateGameArea, 20);        
    },
    stop : function() {
        clearInterval(this.interval);
    },    
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}

function component(width, height, color, x, y, type) {
    this.type = type;
    this.width = width;
    this.height = height;
    this.x = x;
    this.y = y;    
    this.speedX = 0;
    this.speedY = 0;    
    this.gravity = 0.05;
    this.gravitySpeed = 0;
    this.update = function() {
        ctx = myGameArea.context;
        ctx.fillStyle = color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
    this.newPos = function() {
        this.gravitySpeed += this.gravity;
        this.x += this.speedX;
        this.y += this.speedY + this.gravitySpeed;        
    }
}

function updateGameArea() {
    myGameArea.clear();
    myGamePiece.newPos();
    myGamePiece.update();
}
____________________________________________________________________________________
canvas pular com gravidade 

function component(width, height, color, x, y, type) {
    this.type = type;
    this.width = width;
    this.height = height;
    this.x = x;
    this.y = y;
    this.speedX = 0;
    this.speedY = 0;
    this.gravity = 0.1;
    this.gravitySpeed = 0;
    this.bounce = 0.6;
    this.update = class="notranslate">function() {
        ctx = myGameArea.context;
        ctx.fillStyle = color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
    this.newPos = class="notranslate">function() {
        this.gravitySpeed += this.gravity;
        this.x += this.speedX;
        this.y += this.speedY + this.gravitySpeed;
        this.hitBottom();
    }
    this.hitBottom = class="notranslate">function() {
        var rockbottom = this.gamearea.canvas.height - this.height;
        if (this.y > rockbottom) {
            this.y = rockbottom;
            this.gravitySpeed = -(this.gravitySpeed * this.bounce);
        }
    }
}
_________________________________________________________________________________________
criar componente canvas

<body onload="startGame()">
<script>

var myGamePiece;
var myGamePiece2;
function startGame() {
    myGameArea.start();
    myGamePiece = new component(30, 30, "red", 10, 120);
    myGamePiece2 = new component(30, 30, "red", 50, 120);
}

var myGameArea = {
    canvas : document.createElement("canvas"),
    start : function() {
        this.canvas.width = 480;
        this.canvas.height = 270;
        this.context = 
        this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
    }
}

function component(width, height, color, x, y) {
    this.width = width;
    this.height = height;
    this.x = x;
    this.y = y;
    
    ctx = myGameArea.context;
    ctx.fillStyle = color;
    ctx.fillRect(this.x, this.y, this.width, this.height);
}

</script>

<p>We have added a component to our game, a red square!</p>

</body>

	// Fun√ß√£o para mapear os bot√µes do controle
function mapButtons(buttons) {
  const buttonMap = {
    0: 'A',
    1: 'B',
    2: 'X',
    3: 'Y',
    // Mapeie outros bot√µes conforme necess√°rio
  };
  
  const mappedButtons = [];
  
  for (let i = 0; i < buttons.length; i++) {
    if (buttons[i].pressed) {
      const buttonName = buttonMap[i];
      mappedButtons.push(buttonName);
    }
  }
  
  return mappedButtons;
}

// Fun√ß√£o para mapear os eixos do controle
function mapAxes(axes) {
  const axisMap = {
    0: 'LeftStickX',
    1: 'LeftStickY',
    2: 'RightStickX',
    3: 'RightStickY',
    // Mapeie outros eixos conforme necess√°rio
  };
  
  const mappedAxes = {};
  
  for (let i = 0; i < axes.length; i++) {
    const axisName = axisMap[i];
    const axisValue = axes[i].toFixed(2); // Arredonda o valor para duas casas decimais
    
    mappedAxes[axisName] = axisValue;
  }
  
  return mappedAxes;
}

// Fun√ß√£o de atualiza√ß√£o para verificar o estado dos controles
function updateGamepadState() {
  const gamepads = navigator.getGamepads();
  
  for (let i = 0; i < gamepads.length; i++) {
    const gamepad = gamepads[i];
    
    if (gamepad) {
      const buttons = mapButtons(gamepad.buttons);
      const axes = mapAxes(gamepad.axes);

      // Fa√ßa o processamento necess√°rio com os bot√µes e eixos mapeados
	   console.log('Eixos:', mappedAxes);
	  game.set_text("txts"," Eixos " +  axes.LeftStickX);
	  game.set_text("txtb"," bot√£o " + buttons);
	 
    }
  }
  
  requestAnimationFrame(updateGamepadState);
}

// Inicia a atualiza√ß√£o do estado dos controles
requestAnimationFrame(updateGamepadState);

<!DOCTYPE html>
<html>
<head>
		<script src="Nandraki.js"></script>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>		
<style>
	body{
	  margin:0px;
	}
	canvas { 
	
	border: solid 1px;	
	margin-left: 5px;
	
	}
</style>
</head>
<body>

debug:
<br>

<script>

// Fun√ß√£o para atualizar os estados dos bot√µes do gamepad
// Fun√ß√£o para atualizar o estado dos bot√µes e eixos do gamepad
function updateGamepadStatus(gamepad) {
  updateGamepadButtons(gamepad.buttons);

  const axes = gamepad.axes;
  const xAxis = axes[0];
  const yAxis = axes[1];

  // Verifica o estado dos eixos
  if (xAxis > 0.5) {
    console.log('Eixo X para a direita');
    // Adicione a√ß√£o correspondente
  } else if (xAxis < -0.5) {
    console.log('Eixo X para a esquerda');
    // Adicione a√ß√£o correspondente
  }

  if (yAxis > 0.5) {
    console.log('Eixo Y para baixo');
    // Adicione a√ß√£o correspondente
  } else if (yAxis < -0.5) {
    console.log('Eixo Y para cima');
    // Adicione a√ß√£o correspondente
  }
}

// Fun√ß√£o para atualizar o estado dos bot√µes do gamepad
function updateGamepadButtons(buttons) {
  for (let i = 0; i < buttons.length; i++) {
    const button = buttons[i];
    const buttonPressed = button.pressed;

    // Verifica o estado do bot√£o
    if (buttonPressed) {
      console.log(`Bot√£o ${i} pressionado`);
      // Adicione a√ß√£o correspondente
    }
  }
}

// Fun√ß√£o para verificar o estado dos gamepads
function checkGamepadStatus() {
  const gamepads = navigator.getGamepads();
  for (let i = 0; i < gamepads.length; i++) {
    const gamepad = gamepads[i];
    if (gamepad) {
      updateGamepadStatus(gamepad);
    }
  }
}

// Fun√ß√£o de anima√ß√£o para verificar o estado dos gamepads continuamente
function animate() {
  checkGamepadStatus();
  requestAnimationFrame(animate);
}

// Inicia a anima√ß√£o
animate();



game.canvas_start("canvas",800,500)	
Nandraki = game.context("canvas")


game.log_key;
game.log_down(logKey1);
x=0
y=0


 function logKey1(e) {
		
	   if( e.code == "ArrowRight") {
			x+=5
		
		}
		if( e.code == "ArrowLeft") {
			x-=5
			
		}

		if( e.code == "ArrowUp"   ) {
			anim="pulo"	
			y-=5

			if(pulo==1 ){
				
				pulo=pulo-1
				
			}
		
		}
		if( e.code == "ArrowDown") {
		
			y+=5

		}
		
  }

function jogo(){
		
	

		Nandraki.clearRect(0, 0,canvas.width,canvas.height);	
		Nandraki.beginPath();
	    Nandraki.stroke();
		Nandraki.fillRect(x,y,50,50);	
	    game.rest(jogo,Nandraki);
		
	}

	game.loop(jogo,Nandraki)






</script>

</body>
</html>

1. Classe ThreeCore
A ThreeCore √© a classe que gerencia o n√∫cleo da cena 3D, como o ambiente, a c√¢mera e o
renderizador. Ela tamb√©m garante que apenas uma inst√¢ncia de ThreeCore seja criada, usando o
padr√£o Singleton. Isso significa que, mesmo se voc√™ tentar criar v√°rias inst√¢ncias dessa classe, voc√™
s√≥ ter√° uma inst√¢ncia em toda a aplica√ß√£o.
Construtor ( constructor ):
Cena 3D: A cena √© onde todos os objetos 3D s√£o colocados e renderizados.
C√¢mera: A c√¢mera √© respons√°vel por exibir o que est√° na cena. Aqui, usamos uma c√¢mera
de perspectiva, que simula como vemos o mundo em 3D, com dist√¢ncias vari√°veis.
Renderizador: √â o motor que desenha a cena 3D na tela. O alpha: true √© utilizado para
que o fundo da cena tenha transpar√™ncia, o que pode ser √∫til para integra√ß√µes com outras
camadas (como a integra√ß√£o com um jogo 2D).
Singleton: ThreeCore.instance = this garante que apenas uma inst√¢ncia da classe seja
criada. Se j√° houver uma inst√¢ncia, ele retorna a inst√¢ncia existente.
M√©todos:
init(container) : Inicializa a cena, adiciona o renderizador ao container da p√°gina HTML
e come√ßa o loop de anima√ß√£o.
animate() : Este m√©todo √© chamado repetidamente atrav√©s de requestAnimationFrame , o
que permite a anima√ß√£o cont√≠nua. Ele renderiza a cena a cada quadro.

2. Classe ThreeFactory
A ThreeFactory √© respons√°vel por criar os objetos 3D fundamentais, como luzes, cubos e c√¢meras.
Esse √© um exemplo de Abstract Factory, j√° que ela centraliza a cria√ß√£o desses objetos.
M√©todos:
createLight() : Cria uma luz pontual (uma luz que emite de um ponto em todas as
dire√ß√µes).
createCube() : Cria um cubo 3D com uma cor verde usando BoxGeometry (geometria do
cubo) e MeshStandardMaterial (material com sombreamento adequado para
renderiza√ß√£o realista).
createCamera() : Cria uma c√¢mera de perspectiva.
O padr√£o Abstract Factory ajuda a abstrair a cria√ß√£o de diferentes tipos de objetos 3D sem que o
c√≥digo do cliente precise saber como esses objetos s√£o criados internamente.

3. Classe EntityBuilder
A EntityBuilder √© uma implementa√ß√£o do padr√£o Builder. Ela permite construir entidades
compostas de forma mais flex√≠vel, adicionando diferentes componentes a uma √∫nica entidade,
como malhas (meshes) e posi√ß√µes.
M√©todos:
addMesh(mesh) : Adiciona um mesh (malha 3D, como um cubo) √† entidade.
setPosition(x, y, z) : Define a posi√ß√£o da entidade no espa√ßo 3D.
build() : Finaliza a constru√ß√£o e retorna a entidade 3D.
O objetivo da classe EntityBuilder √© proporcionar uma maneira f√°cil de criar objetos mais
complexos, ao adicionar diferentes componentes (como malhas) e personalizar atributos de forma
fluida.

4. Classe PrototypeFactory
A PrototypeFactory segue o padr√£o Prototype. Ela permite registrar e clonar objetos 3D, o que √©
√∫til quando voc√™ deseja criar c√≥pias de objetos sem precisar recri√°-los do zero, economizando
recursos e tempo de processamento.

M√©todos:
register(name, object3D) : Registra um objeto 3D com um nome para que ele possa ser
clonado mais tarde.
clone(name) : Clona um objeto registrado anteriormente, retornando uma c√≥pia exata
dele.

5. Classe Game
A classe Game utiliza a ThreeFactory para criar objetos de forma simplificada. Ao chamar o
m√©todo Game.create(type) , ele cria um objeto do tipo especificado (como cube , camera ,
ou light ).
M√©todo create(type) :
Cria os objetos 3D usando a ThreeFactory .
O type pode ser cube , camera ou light , e o m√©todo retorna o objeto correspondente.
Se um tipo desconhecido for passado, o c√≥digo lan√ßa um erro.
Resumo de como funciona:
ThreeCore gerencia o ciclo de vida da cena, a c√¢mera e o renderizador.
ThreeFactory cria objetos 3D, como luzes, cubos e c√¢meras.
EntityBuilder ajuda a construir entidades 3D compostas (como adicionar malhas e definir
posi√ß√µes).
PrototypeFactory permite clonar objetos registrados.
Game √© a interface simplificada para criar objetos e interagir com a cena 3D de maneira f√°cil e
r√°pida.

Objeto de Mapeamento: Criamos um objeto objects que mapeia os tipos de objetos ('cube', 'camera', 'light') para as suas respectivas inst√¢ncias criadas pelo ThreeFactory.

Acesso R√°pido: Agora, ao chamar Game.create(type), o c√≥digo retorna o objeto correspondente diretamente. Se o tipo n√£o existir no objeto objects, ser√° lan√ßado um erro.

Simples e Eficiente: A cria√ß√£o dos objetos √© feita de forma bem simples, sem a necessidade de uma estrutura switch.

Benef√≠cios:
O c√≥digo fica mais enxuto e f√°cil de entender.

A escalabilidade fica mais f√°cil: basta adicionar novos tipos de objetos no array objects e a funcionalidade estar√° pronta para ser utilizada.

Evitamos a complexidade do switch, tornando a leitura do c√≥digo mais fluida.

(Pr√≥ximo) Integra√ß√£o real do salvamento/carregamento em localStorage

(Pr√≥ximo) Painel de Console & Diagn√≥stico embutido na interface

(Pr√≥ximo) Filtro e tags din√¢micas nos scripts da Cena

(Pr√≥ximo) Persist√™ncia autom√°tica dos scripts entre recarregamentos

( ) Criar m√≥dulo de f√≠sica b√°sica (colisores, gravidade simples)

( ) Desenvolver sistema de c√¢mera com controle de movimento

( ) Adicionar suporte a importa√ß√£o de modelos externos (GLTF/OBJ)

( ) Implementar sistema de materiais personalizados

( ) Criar GUI m√≠nima para visualiza√ß√£o e depura√ß√£o da cena

( ) Sistema de exporta√ß√£o da cena como JSON

( ) Criar sistema de carregamento de cenas (load/save)

( ) Adicionar sistema de input (teclado, mouse, toque)

( ) Implementar m√≥dulo de √°udio 3D

( ) Adicionar sistema de anima√ß√µes b√°sicas (keyframes)

( ) Criar m√≥dulo de ilumina√ß√£o avan√ßada (ambient, direcional, sombras)

( ) Integrar com Nandraki.js para sobreposi√ß√£o de UI 2D

( ) Sistema de entidades baseadas em componentes (ECS simplificado)

( ) Modo de build/exporta√ß√£o para Web (embed f√°cil)


üöÄ Curto Prazo (1‚Äì2 dias)
Painel de Console & Diagn√≥stico

Integrar o HTML/CSS/JS do painel que mostra:

Logs internos (logToConsole) com timestamp.

Status do loop (rodando/pausado e FPS aproximado).

Captura de erros isolados de cada componente.

Bot√µes de ‚Äúüõë‚Äù para pausar/despausar componentes individualmente.

Filtro e Tags nos Scripts da Cena

Implementar input de busca para filtrar por nome do objeto, nome do script ou trecho de c√≥digo.

Suporte a ‚Äútags‚Äù (por exemplo: enemy, player, ui) para agrupar e esconder/grupar se√ß√µes rapidamente.

Persist√™ncia Local dos Scripts

Salvar Autom√°tico em localStorage (ou IndexedDB):

draki.preload, draki.fixload e scripts da Cena.

Carregar ao abrir o modal, mantendo o estado entre recarregamentos.

üîß M√©dio Prazo (1‚Äì2 semanas)
Editor de C√≥digo Avan√ßado

Substituir textareas b√°sicas por um editor leve (ex: CodeMirror ou Monaco).

Syntax highlighting e autocompletar b√°sico de APIs DrakiJs (drak(), addComponent, etc.).

Sistema de Ciclo de Vida de Componentes

Adicionar hooks: onStart(), onUpdate(), onDestroy().

Gerenciamento autom√°tico de destrui√ß√£o ao remover objetos da cena.

Exporta√ß√£o/Importa√ß√£o Avan√ßada de JSON

Permitir exportar presets de scripts (preload/fixload/cena) como arquivos .drakijs.

UI para importar m√∫ltiplos presets, mesclar ou substituir cenas inteiras.

Colaps√°veis e Organiza√ß√£o Hier√°rquica

Tornar os grupos de scripts totalmente expans√≠veis/colaps√°veis.

Suporte ‚Äúexpandir tudo‚Äù / ‚Äúrecolher tudo‚Äù e salvar estado de expans√£o.

üåê Longo Prazo (1‚Äì2 meses)
Plugin System & Marketplace

Criar um sistema de plugins onde usu√°rios possam empacotar e compartilhar componentes e scripts.

Interface para instalar/remover plugins diretamente no Loop Viewer.

Debug Visual & Perfil de Performance

Gr√°fico simples de tempo gasto por componente (profile de cada update()).

Heatmap de FPS da cena e memory leak detection.

Colabora√ß√£o em Tempo Real

Sincronizar edi√ß√£o de scripts entre m√∫ltiplos usu√°rios via WebSocket ou WebRTC.

Chat integrado e change tracking nos scripts.

Exporta√ß√£o de Build e CLI

Ferramenta de linha de comando para gerar builds est√°ticos da cena (incluindo scripts).

Output otimizado para produ√ß√£o (minifica√ß√£o e tree-shaking).

Documenta√ß√£o Interativa

Gerador autom√°tico de docs para componentes e m√©todos (a partir de JSDoc nos seus scripts).

Playground interativo no WebSim para experimentar APIs em tempo real.

üëâ Recomenda√ß√µes Imediatas
Escolha uma iniciativa de Curto Prazo (console ou filtro) e finalize-a antes de pular para recursos maiores.

Mantenha o foco na modularidade: cada painel ou funcionalidade deve poder existir isoladamente e ser ‚Äúplug√°vel‚Äù no ThreeCore.

Teste constantes: crie uma pequena su√≠te de testes manuais (ou automatizados com Jasmine/Mocha) para garantir que Preload, Fixload e Loop Viewer n√£o quebrem conforme novas features entram.
üöÄ Curto Prazo (1‚Äì2 dias)
Painel de Console & Diagn√≥stico

Integrar o HTML/CSS/JS do painel que mostra:

Logs internos (logToConsole) com timestamp.

Status do loop (rodando/pausado e FPS aproximado).

Captura de erros isolados de cada componente.

Bot√µes de ‚Äúüõë‚Äù para pausar/despausar componentes individualmente.

Filtro e Tags nos Scripts da Cena

Implementar input de busca para filtrar por nome do objeto, nome do script ou trecho de c√≥digo.

Suporte a ‚Äútags‚Äù (por exemplo: enemy, player, ui) para agrupar e esconder/grupar se√ß√µes rapidamente.

Persist√™ncia Local dos Scripts

Salvar Autom√°tico em localStorage (ou IndexedDB):

draki.preload, draki.fixload e scripts da Cena.

Carregar ao abrir o modal, mantendo o estado entre recarregamentos.

üîß M√©dio Prazo (1‚Äì2 semanas)
Editor de C√≥digo Avan√ßado

Substituir textareas b√°sicas por um editor leve (ex: CodeMirror ou Monaco).

Syntax highlighting e autocompletar b√°sico de APIs DrakiJs (drak(), addComponent, etc.).

Sistema de Ciclo de Vida de Componentes

Adicionar hooks: onStart(), onUpdate(), onDestroy().

Gerenciamento autom√°tico de destrui√ß√£o ao remover objetos da cena.

Exporta√ß√£o/Importa√ß√£o Avan√ßada de JSON

Permitir exportar presets de scripts (preload/fixload/cena) como arquivos .drakijs.

UI para importar m√∫ltiplos presets, mesclar ou substituir cenas inteiras.

Colaps√°veis e Organiza√ß√£o Hier√°rquica

Tornar os grupos de scripts totalmente expans√≠veis/colaps√°veis.

Suporte ‚Äúexpandir tudo‚Äù / ‚Äúrecolher tudo‚Äù e salvar estado de expans√£o.

üåê Longo Prazo (1‚Äì2 meses)
Plugin System & Marketplace

Criar um sistema de plugins onde usu√°rios possam empacotar e compartilhar componentes e scripts.

Interface para instalar/remover plugins diretamente no Loop Viewer.

Debug Visual & Perfil de Performance

Gr√°fico simples de tempo gasto por componente (profile de cada update()).

Heatmap de FPS da cena e memory leak detection.

Colabora√ß√£o em Tempo Real

Sincronizar edi√ß√£o de scripts entre m√∫ltiplos usu√°rios via WebSocket ou WebRTC.

Chat integrado e change tracking nos scripts.

Exporta√ß√£o de Build e CLI

Ferramenta de linha de comando para gerar builds est√°ticos da cena (incluindo scripts).

Output otimizado para produ√ß√£o (minifica√ß√£o e tree-shaking).

Documenta√ß√£o Interativa

Gerador autom√°tico de docs para componentes e m√©todos (a partir de JSDoc nos seus scripts).

Playground interativo no WebSim para experimentar APIs em tempo real.

üëâ Recomenda√ß√µes Imediatas
Escolha uma iniciativa de Curto Prazo (console ou filtro) e finalize-a antes de pular para recursos maiores.

Mantenha o foco na modularidade: cada painel ou funcionalidade deve poder existir isoladamente e ser ‚Äúplug√°vel‚Äù no ThreeCore.

Teste constantes: crie uma pequena su√≠te de testes manuais (ou automatizados com Jasmine/Mocha) para garantir que Preload, Fixload e Loop Viewer n√£o quebrem conforme novas features entram.
drak() ‚Äî O m√©todo oficial da engine (ex: drak("Inimigo").set("vida", 10);)

echo() ‚Äî Puxa e ecoa os dados do objeto

eye() ‚Äî "Olha" para um objeto

callTo() ‚Äî Chama outro objeto da cena

touch() ‚Äî Toca/interage com outro objeto

bind() ‚Äî Ex: bind("Player").position.set(0, 1, 0);

ref() ‚Äî Puxa uma refer√™ncia (tipo "refer√™ncia cruzada")

link() ‚Äî Liga o script a um objeto

pointTo() ‚Äî Aponta para um objeto na hierarquia

hook() ‚Äî Ganchos para manipula√ß√£o de outros objetos

ThreeCore (Singleton) ‚Äì configura√ß√£o de cena, c√¢mera, renderer e loop principal que executa scripts e componentes

 ThreeFactory (Abstract Factory) ‚Äì m√©todos createLight(), createCube(), createCamera()

 EntityBuilder (Builder) ‚Äì constru√ß√£o encadeada de entidades com addMesh() e setPosition()

 PrototypeFactory (Prototype) ‚Äì registro (register) e clonagem (clone) de prot√≥tipos de objetos

 ComponentRegistry ‚Äì registro global e instancia√ß√£o de classes de componente reutiliz√°veis

 TagSystem ‚Äì adi√ß√£o, remo√ß√£o e consulta de tags em objetos, e busca global por tag

 Game.create() (Factory Naming) ‚Äì cria√ß√£o de objetos (cube, camera, light) com mapeamento autom√°tico de nome

 drak() (Dynamic Accessor) ‚Äì acesso a objetos por nome e manipula√ß√£o via m√©todos set, get, script, addComponent, removeComponent, addTag etc.

 getByTag() ‚Äì fun√ß√£o utilit√°ria para buscar todos os objetos com uma tag espec√≠fica

 
( ) Criar m√≥dulo de f√≠sica b√°sica (colisores, gravidade simples)

( ) Desenvolver sistema de c√¢mera com controle de movimento

( ) Adicionar suporte a importa√ß√£o de modelos externos (GLTF/OBJ)

( ) Implementar sistema de materiais personalizados

( ) Criar GUI m√≠nima para visualiza√ß√£o e depura√ß√£o da cena

( ) Sistema de exporta√ß√£o da cena como JSON

( ) Criar sistema de carregamento de cenas (load/save)

( ) Adicionar sistema de input (teclado, mouse, toque)

( ) Implementar m√≥dulo de √°udio 3D

( ) Adicionar sistema de anima√ß√µes b√°sicas (keyframes)

( ) Criar m√≥dulo de ilumina√ß√£o avan√ßada (ambient, direcional, sombras)

( ) Integrar com Nandraki.js para sobreposi√ß√£o de UI 2D

( ) Sistema de entidades baseadas em componentes (ECS simplificado)

( ) Modo de build/exporta√ß√£o para Web (embed f√°cil)
